\documentclass[a4paper,11pt]{article}
\usepackage[a4paper]{geometry}
\usepackage{hyperref}
\usepackage{syntax}
\usepackage{listings}
\lstset{language=C}
\usepackage{parskip}
\usepackage{setspace}
\onehalfspace

\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\author{Christian Manning -- p0928544x\\
De Montfort University}
\title{IMAT3451 -- Final Year Project\\
    Dynamic Data Structure Visualisation\\
    User Documentation
}
\date{April 2012}

\begin{document}
\maketitle

\tableofcontents

\pagebreak

\section{Introduction}

The Dynamic Data Structure Visualisation (DDSV) application aims to provide help to students who are learning to program.
The focus of this application is on the concept of pointers; specifically, how they are used to build data structures.

It does this by utilising a graphical user interface (GUI) to provide a visualisation containing graphical representations of abstract data types and pointers to them.
This facilitates the visual construction of a data structure, which can then be manipulated to simulate algorithmic operations.

Another interface to this application utilises the expressiveness of a programming language from the GUI in the form of an interpreter.
The language accepted by this interpreter, defined later in this document, is a small subset of the C programming language which has quite a low level model and so pointers are exposed to the user more readily.
With this interpreter, C code can then be visualised graphically, allowing the user to learn 

\section{User Interface}

\section{Interpreted Language}

\subsection{Specification}

This is the formal grammar specification of the interpreted language using an Extended Backus-Naur Form (EBNF)-like notation, with some brief descriptions.

\noindent\textit{assign\_op} ::=
    `$=$'
    ;

\noindent\textit{logical\_or\_op} ::=
    `$||$'
    ;
\noindent\textit{logical\_and\_op} ::=
    `$\&\&$'
    ;
\noindent\textit{equality\_op} ::=
    `$==$'
    $|$ `$!=$'
    ;
\noindent\textit{relational\_op} ::=
    `$<$'
    $|$ `$\leq$'
    $|$ `$>$'
    $|$ `$\geq$'
\noindent\textit{additive\_op} ::=
    `$+$'
    $|$ `$-$'
\noindent\textit{multiplicative\_op} ::=
    `$*$'
    $|$ `$/$'
    ;

\noindent Listed above are the \textit{binary operators}, meaning they require two \textit{operands}. These are arithmetic and boolean operators.

\noindent\textit{unary\_op} ::=
    `$+$'
    $|$ `$-$'
    $|$ `$!$'
    $|$ `$*$'
    $|$ `$\&$'
    ;

\noindent\textit{Unary operators} require only one \textit{operand}.

\noindent\textit{struct\_op} ::=
    `$\rightarrow$'
    $|$ `$.$'

\noindent\textit{Struct operators} are used to select members of a struct variable.
    
\noindent\textit{memory\_op} ::=
    `\verb+new+'
    
\noindent The \textit{new} operator is used for dynamically allocating memory.

\noindent\textit{keywords} ::=
    `\verb+true+' $|$ `\verb+false+' $|$ `\verb+if+' $|$ `\verb+while+' $|$ `\verb+struct+' $|$ `\verb+return+' $|$ `\verb+new+'
    ;

\noindent These are the \textit{keywords} which are reserved words and cannot be used outside of their required context.

\noindent\textit{types} ::=
    `\verb+void+' $|$ `\verb+int+' $|$ `\verb+bool+' ;
    
\noindent These are the predefined primitive \textit{types} that are used for declaring variables, etc.

\begin{grammar}
<identifier> ::=
	-(keywords | types) ,
	alpha | `\_' , \{ alpha | digit | `\_' \} ;
\end{grammar}
An \textit{identifier} must not be a \textit{keyword}, a primitive type or begin with a digit. It must start with an alphabetic character or an underscore (\_) to be optionally followed by zero or more alphabetic characters, digits or underscores. 

\begin{grammar}
        <assignment_expression> ::= <logical_OR_expression> [<unary_assign>];

        <allocation_expression> ::= <memory_op> <type_specifier>;

        <unary_assign> ::= <assign_op>\\
        (<allocation_expression> \alt <logical_OR_expression>);

        <logical_OR_expression> ::= <logical_AND_expression>\\
        \{<logical_or_op> <logical_AND_expression>\};

        <logical_AND_expression> ::= <equality_expression>\\
        \{<logical_and_op> <equality_expression>\};

        <equality_expression> ::= <relational_expression>\\
        \{<equality_op> <relational_expression>\};

        <relational_expression> ::= <additive_expression>\\
        \{<relational_op> <additive_expression>\};

        <additive_expression> ::= <multiplicative_expression>\\
        \{<additive_op> <multiplicative_expression>\};

        <multiplicative_expression> ::= <unary_expression>\\
        \{<multiplicative_op> <unary_expression>\};

        <unary_expression> ::=
                [<unary_op>]
               <postfix_expression>
            ;

        <struct_expr> ::= <struct_op> <identifier>;

        <postfix_expression> ::=
                <primary_expression>\\
               \{<struct_expr> \alt <postfix_op>\}
            ;

        <primary_expression> ::=
                int
            \alt   <identifier>
            \alt   bool
            \alt   `(' <logical_OR_expression> `)'
            ;
\end{grammar}
\textit{Assignment expression} is the catch-all expression rule.
This rule uses recursion so that it also takes into account operator precedence without additional algorithms.
Each of its constituent rules have a specific set of operators, each with their own precedence.

As can be seen from the top rule only one variable can be assigned at a time, whereas the rest can be composed of any of the others, allowing complex expressions to be formed.
Available primitive types for constants and variables are integer and boolean only.

An \textit{allocation expression} is one which allocates memory of a specified type to be assigned to a pointer.

\begin{grammar}
        <type_specifier> ::=
                <types>
            \alt   <struct_specifier>
            ;

        <declarator> ::= [`*'] <identifier>;
        
	<declaration> ::= <type_specifier> [<init_declarator>] `;';

        <init_declarator> ::= <declarator>
        [`=' <allocation_expression>
        \alt <logical_OR_expression>];


        <struct_member_declaration> ::= <type_specifier> <declarator> `;';

        <struct_specifier> ::=
                `struct' <identifier> [`{' \{<struct_member_declaration>\} `}';
\end{grammar}
The above lists the rule to match a \verb+struct+ definition, which may contain one or more member declarations.
A struct member declaration must not be initialised in any form.
Variable declarations may have a single initialisation from an expression.
The optional `*' denotes a pointer type.

\begin{grammar}
<statement_list> ::=
    \{<statement>\}
    ;

<statement> ::=
	<declaration>
    \alt   <assignment_expression> `;'
    \alt   <if_statement>
    \alt   <while_statement>
    \alt   <return_statement>
    \alt   <compound_statement>
    ;
\end{grammar}

Any of the above listed \textit{statements} can take the place of a $\langle statement\_\rangle$ instance.

\begin{grammar}
<if_statement> ::=
	`if'
       `('
       <logical_OR_expression>
       `)'
       <statement>
    ;
\end{grammar}

An \textit{if statement} is a conditional which will only execute its encompassed statement if a condition is evaluated as \verb+true+.
This condition can be anything that can be represented by a \textit{logical or expression}, which is any expression other than an assignment.

\begin{grammar}
<while_statement> ::=
	`while'
       '('
       <logical_OR_expression>
       `)'
       <statement>
    ;
\end{grammar}

The \textit{while statement} is a looping statement which will execute its enclosed statement for as long as its conditional \textit{logical or expression} evaluates to \verb+true+.

\begin{grammar}
<compound_statement> ::=
    '\{' [<statement_list>] '\}'
    ;
\end{grammar}
A \textit{compound statement} is an list of zero, one or many \textit{statements} enclosed in braces (`\{' \& `\}').
\begin{grammar}
<return_statement> ::=
	`return'
    [<logical_OR_expression>]
       `;'
    ;
\end{grammar}

\begin{grammar}
        <argument> ::=
                <type_specifier>
            <init_declarator>
            ;

        <function_definition> ::=
                <type_specifier>
            <declarator>\\
            `('
            [\%<argument>]
               `)'\\
            <compound_statement>
            ;

        <translation_unit> ::=
            \{  <statement>
            \alt   <function_definition>
            \}
            ;
\end{grammar}

The \textit{translation unit} consists of a list of both \textit{function} declarations and \textit{statement lists}. This is root of all that can be passed to the interpreter, i.e.\ everything must be entered in this form.

\subsection{Operator Precedence}
The following table shows the operator precedence of the interpreted language, from lowest to highest.

\begin{tabular}{| c | l | l |}
\hline
Precedence & Operator & Description \\ \hline
1 & , & Comma \\ \hline
2 & = & Assignment \\ \hline
3 & $\parallel$ & Logical OR \\ \hline
4 & \&\& & Logical AND \\ \hline
5 & == & Equal \\
  & != & Not Equal \\ \hline
6 & $<$ & Less than \\
  & $\leq$ & Less than or equal to \\
  & $>$ & More than \\
  & $\geq$ & More than or equal to \\ \hline
7 & + (binary) & Addition \\
  & $-$ (binary) & Subtraction \\ \hline
8 & * & Multiplication \\
  & / & Division \\ \hline
9 & + (unary) & Plus \\
  & -- (unary) & Minus \\
  & ! & Not \\
  & $\&$ & Address of \\
  & * (unary) & Dereference \\ \hline
10 & $-$$>$ & Select element through pointer \\
   & . & Select element \\ \hline
\end{tabular}

The \verb+new+ operator does not have a particular precedence as it can only be used in assignments and declarations, effectively giving it a precedence higher than that of `=', though it is considered a special operator.

\subsection{Notes}

This language may be similar to C but their are some notable exceptions and omissions.


\subsection{Examples}

\subsubsection{Variable Declaration}

\begin{lstlisting}
//declare an integer variable named "a"
int a;
//assignment on declaration
int b = 3;
//assignment from an expression
int c = b + 2;

//declare a pointer and assign it the address of a
int * p = &a;
*p = 51; // a == 51

//declare a pointer variable and allocate it some memory
int * x = new int;
//dereference and assign
*x = 123;
\end{lstlisting}

\subsubsection{Function Declaration}

\begin{lstlisting}
int factorial(int n) {
  if(n < 1)
    return 1;
  else
    return n * factorial(n-1);
}
\end{lstlisting}

\subsubsection{Struct Declaration}

\begin{lstlisting}
//Define a struct
struct point {
  int x;
  int y;
};

//Define and declare a struct variable in one statement
struct point {
  int x;
  int y;
} p1;

struct point * ptr = new struct point;
ptr->x = 42;
ptr->y = 24;
\end{lstlisting}

\subsubsection{Struct Instantiation}

\begin{lstlisting}
struct point p1;
p1.x = 4;
p1.y = 6;
\end{lstlisting}


\end{document}
